"use strict";

exports.call = call;
exports.apply = apply;
exports.bind = bind;
exports.not = not;
exports.truthy = truthy;
exports.falsy = falsy;
exports.is = is;
exports.isNumber = isNumber;
exports.isFinite = isFinite;
exports.isInteger = isInteger;
exports.isNatural = isNatural;
exports.isNaN = isNaN;
exports.isInfinity = isInfinity;
exports.isString = isString;
exports.isBoolean = isBoolean;
exports.isSymbol = isSymbol;
exports.isKey = isKey;
exports.isPrimitive = isPrimitive;
exports.isComplex = isComplex;
exports.isInstance = isInstance;
exports.isFunction = isFunction;
exports.isObject = isObject;
exports.isDict = isDict;
exports.isStruct = isStruct;
exports.isArray = isArray;
exports.isList = isList;
exports.isRegExp = isRegExp;
exports.isDate = isDate;
exports.isValidDate = isValidDate;
exports.isInvalidDate = isInvalidDate;
exports.isPromise = isPromise;
exports.isIterator = isIterator;
exports.isNil = isNil;
exports.isSomething = isSomething;
exports.isEmpty = isEmpty;
exports.testBy = testBy;
exports.test = test;
exports.onlyString = onlyString;
exports.onlyList = onlyList;
exports.onlyDict = onlyDict;
exports.onlyStruct = onlyStruct;
exports.toArray = toArray;
exports.each = each;
exports.fold = fold;
exports.foldRight = foldRight;
exports.map = map;
exports.flatMap = flatMap;
exports.flatMapDeep = flatMapDeep;
exports.mapFilter = mapFilter;
exports.filter = filter;
exports.reject = reject;
exports.compact = compact;
exports.find = find;
exports.findRight = findRight;
exports.findIndex = findIndex;
exports.findIndexRight = findIndexRight;
exports.indexOf = indexOf;
exports.lastIndexOf = lastIndexOf;
exports.includes = includes;
exports.procure = procure;
exports.every = every;
exports.some = some;
exports.slice = slice;
exports.append = append;
exports.prepend = prepend;
exports.remove = remove;
exports.insertAtIndex = insertAtIndex;
exports.removeAtIndex = removeAtIndex;
exports.adjoin = adjoin;
exports.toggle = toggle;
exports.concat = concat;
exports.flatten = flatten;
exports.flattenDeep = flattenDeep;
exports.head = head;
exports.tail = tail;
exports.init = init;
exports.last = last;
exports.take = take;
exports.drop = drop;
exports.reverse = reverse;
exports.sort = sort;
exports.sortBy = sortBy;
exports.intersection = intersection;
exports.keyBy = keyBy;
exports.groupBy = groupBy;
exports.uniq = uniq;
exports.uniqBy = uniqBy;
exports.partition = partition;
exports.sum = sum;
exports.sumBy = sumBy;
exports.min = min;
exports.max = max;
exports.minBy = minBy;
exports.maxBy = maxBy;
exports.findMinBy = findMinBy;
exports.findMaxBy = findMaxBy;
exports.range = range;
exports.get = get;
exports.scan = scan;
exports.getIn = getIn;
exports.getter = getter;
exports.keys = keys;
exports.values = values;
exports.entries = entries;
exports.eachVal = eachVal;
exports.foldVals = foldVals;
exports.mapVals = mapVals;
exports.mapKeys = mapKeys;
exports.mapValsSort = mapValsSort;
exports.pickBy = pickBy;
exports.omitBy = omitBy;
exports.pickKeys = pickKeys;
exports.omitKeys = omitKeys;
exports.findVal = findVal;
exports.findKey = findKey;
exports.everyVal = everyVal;
exports.someVal = someVal;
exports.invert = invert;
exports.invertBy = invertBy;
exports.size = size;
exports.vacate = vacate;
exports.add = add;
exports.sub = sub;
exports.mul = mul;
exports.div = div;
exports.rem = rem;
exports.lt = lt;
exports.gt = gt;
exports.lte = lte;
exports.gte = gte;
exports.inc = inc;
exports.dec = dec;
exports.id = id;
exports.di = di;
exports.val = val;
exports.noop = noop;
exports.rethrow = rethrow;
exports.assign = assign;
exports.maskBy = maskBy;
exports.mask = mask;
exports.validate = validate;
exports.validateEach = validateEach;
exports.validateInstance = validateInstance;
exports.show = show;
exports.global = exports.first = exports.negate = exports.bool = void 0;
// See impl.md
// Minifiable aliases
var Object_ = Object;
var NOP = Object_.prototype;
var has = NOP.hasOwnProperty;
var Array_ = Array;
var NAP = Array_.prototype;
/** Fun **/
// Tries to avoid allocation of `arguments` to minimize performance overhead.
// As a side effect, the function is called with `this = fun`.

function call(fun) {
  return fun.call.apply(fun, arguments);
} // Called with `this = fun` for consistency with `call` and `bind`.


function apply(fun, args) {
  return fun.apply(fun, args);
} // Tries to avoid allocation of `arguments` to minimize performance overhead.
// As a side effect, the function is called with `this = fun`.


function bind(fun) {
  return fun.bind.apply(fun, arguments);
}

function not(fun) {
  validate(fun, isFunction);
  return function not_() {
    return !fun.apply(null, arguments);
  };
}
/** Bool **/
// Same as global `Boolean`, redefined for symmetry with `negate/falsy`.


var bool = truthy;
exports.bool = bool;

function truthy(value) {
  return !!value; // eslint-disable-line no-implicit-coercion
}

var negate = falsy;
exports.negate = negate;

function falsy(value) {
  return !value;
}

function is(one, other) {
  return one === other || isNaN(one) && isNaN(other);
}

function isNumber(value) {
  return typeof value === 'number';
}

function isFinite(value) {
  return isNumber(value) && !isNaN(value) && !isInfinity(value);
}

function isInteger(value) {
  return isNumber(value) && value % 1 === 0;
}

function isNatural(value) {
  return isInteger(value) && value >= 0;
}

function isNaN(value) {
  return value !== value; // eslint-disable-line no-self-compare
}

function isInfinity(value) {
  return value === Infinity || value === -Infinity;
}

function isString(value) {
  return typeof value === 'string';
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function isSymbol(value) {
  return typeof value === 'symbol';
}

function isKey(value) {
  return isString(value) || isSymbol(value) || isBoolean(value) || isFinite(value);
}

function isPrimitive(value) {
  return !isComplex(value);
}

function isComplex(value) {
  return isObject(value) || isFunction(value);
}

function isInstance(value, Class) {
  return isComplex(value) && value instanceof Class;
}

function isFunction(value) {
  return typeof value === 'function';
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

function isDict(value) {
  if (!isObject(value)) return false;
  var proto = Object_.getPrototypeOf(value);
  return proto === null || proto === NOP;
}

function isStruct(value) {
  return isObject(value) && !isList(value);
}

function isArray(value) {
  return isInstance(value, Array_);
}

function isList(value) {
  return isObject(value) && (isArray(value) || isNatural(value.length) && (!isDict(value) || has.call(value, 'callee')));
}

function isRegExp(value) {
  return isInstance(value, RegExp);
}

function isDate(value) {
  return isInstance(value, Date);
}

function isValidDate(value) {
  return isDate(value) && isFinite(value.valueOf());
}

function isInvalidDate(value) {
  return isDate(value) && !isValidDate(value);
}

function isPromise(value) {
  return isComplex(value) && isFunction(value.then) && isFunction(value.catch);
}

function isIterator(value) {
  return isObject(value) && isFunction(value.next) && isFunction(value.return) && isFunction(value.throw);
}

function isNil(value) {
  return value == null;
}

function isSomething(value) {
  return value != null;
}

function isEmpty(value) {
  return !size(value);
}

function testBy(value, pattern) {
  return isFunction(pattern) ? bool(pattern(value)) : isPrimitive(pattern) ? is(value, pattern) : isRegExp(pattern) ? isString(value) && pattern.test(value) : isList(pattern) ? isList(value) && every(pattern, testAt, value) : isStruct(pattern) ? isStruct(value) && everyVal(pattern, testAt, value) : false;
}

function testAt(pattern, key, value) {
  return testBy(value[key], pattern);
}

function test(pattern) {
  return function test_(value) {
    return testBy(value, pattern);
  };
}
/** Casts **/


function onlyString(value) {
  if (value == null) return '';
  validate(value, isString);
  return value;
}

function onlyList(value) {
  if (value == null) return [];
  validate(value, isList);
  return value;
}

function onlyDict(value) {
  if (value == null) return {};
  validate(value, isDict);
  return value;
}

function onlyStruct(value) {
  if (value == null) return {};
  validate(value, isStruct);
  return value;
}

function toArray(value) {
  return isArray(value) ? value : slice(value);
}
/** List **/


function each(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = 0; i < list.length; i += 1) {
    fun(list[i], i, a, b, c, d, e);
  }
}

function fold(list, acc, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = 0; i < list.length; i += 1) {
    acc = fun(acc, list[i], i, a, b, c, d, e);
  }

  return acc;
}

function foldRight(list, acc, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = list.length - 1; i >= 0; i -= 1) {
    acc = fun(acc, list[i], i, a, b, c, d, e);
  }

  return acc;
}

function map(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var out = Array_(list.length);

  for (var i = 0; i < list.length; i += 1) {
    out[i] = fun(list[i], i, a, b, c, d, e);
  }

  return out;
}

function flatMap(list, fun, a, b, c, d, e) {
  return flatten(map(list, fun, a, b, c, d, e));
}

function flatMapDeep(list, fun, a, b, c, d, e) {
  return flattenDeep(map(list, fun, a, b, c, d, e));
}

function mapFilter(list, fun, a, b, c, d, e) {
  return compact(map(list, fun, a, b, c, d, e));
}

function filter(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var out = [];

  for (var i = 0; i < list.length; i += 1) {
    if (fun(list[i], i, a, b, c, d, e)) out.push(list[i]);
  }

  return out;
}

function reject(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return filter(list, notBy, fun, a, b, c, d, e);
}

function notBy(value, key, fun, a, b, c, d, e) {
  return !fun(value, key, a, b, c, d, e);
}

function compact(list) {
  return filter(list, id);
}

function find(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  return list[findIndex(list, fun, a, b, c, d, e)];
}

function findRight(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  return list[findIndexRight(list, fun, a, b, c, d, e)];
}

function findIndex(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = 0; i < list.length; i += 1) {
    if (fun(list[i], i, a, b, c, d, e)) return i;
  }

  return -1;
}

function findIndexRight(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = list.length; --i >= 0;) {
    if (fun(list[i], i, a, b, c, d, e)) return i;
  }

  return -1;
}

function indexOf(list, value) {
  return findIndex(list, isAt, value);
}

function lastIndexOf(list, value) {
  return findIndexRight(list, isAt, value);
}

function isAt(candidate, _i, value) {
  return is(candidate, value);
}

function includes(list, value) {
  return indexOf(list, value) !== -1;
}

function procure(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = 0; i < list.length; i += 1) {
    var result = fun(list[i], i, a, b, c, d, e);
    if (result) return result;
  }

  return undefined;
}

function every(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = 0; i < list.length; i += 1) {
    if (!fun(list[i], i, a, b, c, d, e)) return false;
  }

  return true;
}

function some(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);

  for (var i = 0; i < list.length; i += 1) {
    if (fun(list[i], i, a, b, c, d, e)) return true;
  }

  return false;
}

function slice(list, start, end) {
  return NAP.slice.call(onlyList(list), start, end);
}

function append(list, value) {
  return toArray(list).concat([value]);
}

function prepend(list, value) {
  return [value].concat(toArray(list));
}

function remove(list, value) {
  return removeAtIndex(list, indexOf(list, value));
}

function insertAtIndex(list, index, value) {
  list = slice(list);
  validate(index, isNatural);

  if (!(index <= list.length)) {
    throw Error("index " + index + " out of bounds for length " + list.length);
  }

  list.splice(index, 0, value);
  return list;
}

function removeAtIndex(list, index) {
  list = onlyList(list);
  validate(index, isInteger);

  if (isNatural(index) && index < list.length) {
    list = slice(list);
    list.splice(index, 1);
  }

  return list;
}

function adjoin(list, value) {
  return includes(list, value) ? toArray(list) : append(list, value);
}

function toggle(list, value) {
  return includes(list, value) ? remove(list, value) : append(list, value);
} // Uses native concat because it seems to perform very well in many JS engines.


function concat() {
  return NAP.concat.apply([], map(arguments, toArray));
}
/*
This could be made more efficient for very large and deep lists by
precalculating the length and allocating the result all at once. Unfortunately
this requires quite a bit of extra code and would be slower for relatively small
lists. It would also be faster to use native array concat, but I haven't found a
way to bypass `.apply` and the argument size limit.
*/


function flatten(list) {
  var out = [];
  each(list, pushFlat, out);
  return out;
}

function pushFlat(value, _i, out) {
  if (isList(value)) for (var i = 0; i < value.length; i += 1) {
    out.push(value[i]);
  } else out.push(value);
}

function flattenDeep(list) {
  var out = [];
  each(list, pushFlatDeep, out);
  return out;
}

function pushFlatDeep(value, _key, out) {
  if (isList(value)) each(value, pushFlatDeep, out);else out.push(value);
}

var first = head;
exports.first = first;

function head(list) {
  return onlyList(list)[0];
}

function tail(list) {
  return slice(list, 1);
}

function init(list) {
  list = onlyList(list);
  return slice(list, 0, list.length - 1);
}

function last(list) {
  list = onlyList(list);
  return list[list.length - 1];
}

function take(list, count) {
  validate(count, isNatural);
  return slice(list, 0, count);
}

function drop(list, count) {
  validate(count, isNatural);
  return slice(list, count);
}

function reverse(list) {
  list = onlyList(list);
  var len = list.length;
  var out = Array_(len);

  for (var i = len; --i >= 0;) {
    out[len - i - 1] = list[i];
  }

  return out;
}

function sort(list, comparator) {
  return slice(list).sort(comparator);
}

function sortBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return sort(list, function compareBy(left, right) {
    return sortCompare(fun(left, a, b, c, d, e), fun(right, a, b, c, d, e));
  });
} // https://tc39.github.io/ecma262/#sec-sortcompare


function sortCompare(left, right) {
  if (left === undefined && right === undefined) return 0;
  if (left === undefined) return 1;
  if (right === undefined) return -1;
  left += ''; // eslint-disable-line no-implicit-coercion

  right += ''; // eslint-disable-line no-implicit-coercion

  if (left < right) return -1;
  if (right < left) return 1;
  return 0;
}

function intersection(left, right) {
  left = onlyList(left);
  right = onlyList(right);
  var lr = left.length <= right.length;
  var lesser = lr ? left : right;
  var greater = lr ? right : left;
  var out = [];
  each(greater, intersectionAdd, out, lesser);
  return out;
}

function intersectionAdd(value, _key, out, control) {
  if (includes(control, value) && !includes(out, value)) out.push(value);
}

function keyBy(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var out = {};

  for (var i = 0; i < list.length; i += 1) {
    var value = list[i];
    var key = fun(value, i, a, b, c, d, e);
    if (isKey(key)) out[key] = value;
  }

  return out;
}

function groupBy(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var out = {};

  for (var i = 0; i < list.length; i += 1) {
    var value = list[i];
    var groupKey = fun(value, i, a, b, c, d, e);

    if (isKey(groupKey)) {
      if (!has.call(out, groupKey)) out[groupKey] = [];
      out[groupKey].push(value);
    }
  }

  return out;
}

function uniq(list) {
  return uniqBy(list, id);
}

function uniqBy(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var out = [];
  var attrs = [];

  for (var i = 0; i < list.length; i += 1) {
    var value = list[i];
    var attr = fun(value, i, a, b, c, d, e);

    if (!includes(attrs, attr)) {
      attrs.push(attr);
      out.push(value);
    }
  }

  return out;
}

function partition(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var accepted = [];
  var rejected = [];

  for (var i = 0; i < list.length; i += 1) {
    var value = list[i];
    if (fun(value, i, a, b, c, d, e)) accepted.push(value);else rejected.push(value);
  }

  return [accepted, rejected];
}

function sum(list) {
  return sumBy(list, id);
}

function sumBy(list, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(fun, isFunction);
  var acc = 0;

  for (var i = 0; i < list.length; i += 1) {
    var value = fun(list[i], i, a, b, c, d, e);
    if (isFinite(value)) acc += value;
  }

  return acc;
}

function min(list) {
  return minBy(list, id);
}

function max(list) {
  return maxBy(list, id);
}

function minBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return fold(list, undefined, compareNumbersBy, lt, fun, a, b, c, d, e);
}

function maxBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return fold(list, undefined, compareNumbersBy, gt, fun, a, b, c, d, e);
}

function compareNumbersBy(acc, value, key, compare, fun, a, b, c, d, e) {
  value = fun(value, key, a, b, c, d, e);
  return !isFinite(value) ? acc : !isFinite(acc) || compare(value, acc) ? value : acc;
}

function findMinBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return findNumBy(list, lt, fun, a, b, c, d, e);
}

function findMaxBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return findNumBy(list, gt, fun, a, b, c, d, e);
} // WTF too large


function findNumBy(list, compare, fun, a, b, c, d, e) {
  list = onlyList(list);
  validate(compare, isFunction);
  validate(fun, isFunction);
  var winningValue = undefined;
  var winningAttr = undefined;

  for (var i = 0; i < list.length; i += 1) {
    var value = list[i];
    var attr = fun(value, i, a, b, c, d, e);

    if (isFinite(attr) && (winningAttr == null || compare(attr, winningAttr))) {
      winningValue = value;
      winningAttr = attr;
    }
  }

  return winningValue;
} // Doesn't need validation: the Array constructor rejects NaN and negatives,
// producing a decent error message.


function range(start, end) {
  var remaining = end - start;
  var out = Array_(remaining);

  while (--remaining >= 0) {
    out[remaining] = start + remaining;
  }

  return out;
}
/**
 * Struct
 */


function get(value, key) {
  return value == null ? undefined : value[key];
}

function scan(value) {
  for (var i = 1; i < arguments.length; i += 1) {
    value = get(value, arguments[i]);
  }

  return value;
}

function getIn(value, path) {
  validate(path, isList);

  for (var i = 0; i < path.length; i += 1) {
    value = get(value, path[i]);
  }

  return value;
}

function getter(key) {
  validate(key, isKey);
  return function get_(value) {
    return get(value, key);
  };
} // Like `Object.keys`, but only for non-list objects.


function keys(value) {
  return Object_.keys(onlyStruct(value));
} // Like `Object.values`, but only for non-list objects.


function values(value) {
  var out = keys(value);

  for (var i = 0; i < out.length; i += 1) {
    out[i] = value[out[i]];
  }

  return out;
} // Like `Object.entries`, but only for non-list objects.


function entries(value) {
  var out = keys(value);

  for (var i = 0; i < out.length; i += 1) {
    out[i] = [out[i], value[out[i]]];
  }

  return out;
}

function eachVal(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    fun(struct[key], key, a, b, c, d, e);
  }
}

function foldVals(struct, acc, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    acc = fun(acc, struct[key], key, a, b, c, d, e);
  }

  return acc;
}

function mapVals(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var out = {};
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    out[key] = fun(struct[key], key, a, b, c, d, e);
  }

  return out;
}

function mapKeys(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var out = {};
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    var value = struct[key];
    var newKey = fun(key, value, a, b, c, d, e);
    if (isKey(newKey)) out[newKey] = value;
  }

  return out;
}

function mapValsSort(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var out = keys(struct).sort();

  for (var i = -1; ++i < out.length;) {
    var key = out[i];
    out[i] = fun(struct[key], key, a, b, c, d, e);
  }

  return out;
}

function pickBy(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var out = {};
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    var value = struct[key];
    if (fun(value, key, a, b, c, d, e)) out[key] = value;
  }

  return out;
}

function omitBy(struct, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return pickBy(struct, notBy, fun, a, b, c, d, e);
}

function pickKeys(struct, keys) {
  struct = onlyStruct(struct);
  validateEach(keys, isKey);
  var out = {};
  each(keys, pickKnown, struct, out);
  return out;
}

function pickKnown(key, _i, src, out) {
  if (has.call(src, key)) out[key] = src[key];
}

function omitKeys(struct, keys) {
  validateEach(keys, isKey);
  var out = {};
  assign(out, struct);
  each(keys, deleteAt, out);
  return out;
}

function deleteAt(key, _i, out) {
  delete out[key];
}

function findVal(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    var value = struct[key];
    if (fun(value, key, a, b, c, d, e)) return value;
  }

  return undefined;
}

function findKey(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    if (fun(struct[key], key, a, b, c, d, e)) return key;
  }

  return undefined;
}

function everyVal(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    if (!fun(struct[key], key, a, b, c, d, e)) return false;
  }

  return true;
}

function someVal(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    if (fun(struct[key], key, a, b, c, d, e)) return true;
  }

  return false;
}

function invert(struct) {
  return invertBy(struct, id);
}

function invertBy(struct, fun, a, b, c, d, e) {
  struct = onlyStruct(struct);
  validate(fun, isFunction);
  var out = {};
  var inputKeys = keys(struct);

  for (var i = 0; i < inputKeys.length; i += 1) {
    var key = inputKeys[i];
    var newKey = fun(struct[key], key, a, b, c, d, e);
    if (isKey(newKey)) out[newKey] = key;
  }

  return out;
}
/** Coll **/
// Only collections (lists and objects) have a size. Functions and primitives,
// including strings, are considered empty.


function size(value) {
  return isList(value) ? value.length : isObject(value) ? keys(value).length : 0;
}

function vacate(value) {
  return size(value) ? value : undefined;
}
/** Ops **/


function add(a, b) {
  return a + b;
}

function sub(a, b) {
  return a - b;
}

function mul(a, b) {
  return a * b;
}

function div(a, b) {
  return a / b;
}

function rem(a, b) {
  return a % b;
}

function lt(a, b) {
  return a < b;
}

function gt(a, b) {
  return a > b;
}

function lte(a, b) {
  return a <= b;
}

function gte(a, b) {
  return a >= b;
}

function inc(a) {
  return a + 1;
}

function dec(a) {
  return a - 1;
}
/** Misc **/
// The "pure" annotation allows UglifyJS to drop this if the result is unused.


var global =
/* #__PURE__ */
Function('return this')(); // eslint-disable-line no-new-func

exports.global = global;

function id(value) {
  return value;
}

function di(_, value) {
  return value;
}

function val(value) {
  return bind(id, value);
}

function noop() {}

function rethrow(value) {
  throw value;
}

function assign(target) {
  validate(target, isComplex);

  for (var i = 1; i < arguments.length; ++i) {
    eachVal(arguments[i], setAt, target);
  }
}

function setAt(value, key, target) {
  target[key] = value;
}

function maskBy(value, pattern) {
  return isFunction(pattern) ? pattern(value) : isPrimitive(pattern) ? pattern : isRegExp(pattern) ? onlyString(value).match(pattern) : isList(pattern) ? map(pattern, maskAt, onlyList(value)) : isStruct(pattern) ? mapVals(pattern, maskAt, onlyStruct(value)) : undefined;
}

function maskAt(pattern, key, value) {
  return maskBy(value[key], pattern);
}

function mask(pattern) {
  return function mask_(value) {
    return maskBy(value, pattern);
  };
}

function validate(value, test) {
  if (!isFunction(test)) {
    throw Error("expected validator function, got " + show(test));
  }

  if (!test(value)) {
    throw Error("expected " + show(value) + " to satisfy test " + show(test));
  }
}

function validateEach(list, test) {
  validate(list, isList);

  for (var i = 0; i < list.length; i += 1) {
    if (!test(list[i])) {
      throw Error("expected " + show(list[i]) + " at index " + i + " to satisfy test " + show(test));
    }
  }
}

function validateInstance(value, Class) {
  if (!isInstance(value, Class)) {
    throw Error("expected " + show(value) + " to be an instance of " + show(Class));
  }
}

function show(value) {
  return isFunction(value) && value.name ? value.name : isArray(value) || isDict(value) ? JSON.stringify(value) : isString(value) ? "\"" + value + "\"" : String(value);
}